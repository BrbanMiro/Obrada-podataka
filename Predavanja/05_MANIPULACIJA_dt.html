<!DOCTYPE html>
<html lang="" xml:lang="">
  <head>
    <title>OBRADA PODATAKA</title>
    <meta charset="utf-8" />
    <meta name="author" content="Luka Sikic, PhD" />
    <link href="libs/remark-css/default.css" rel="stylesheet" />
    <link href="libs/remark-css/metropolis.css" rel="stylesheet" />
    <link href="libs/remark-css/metropolis-fonts.css" rel="stylesheet" />
  </head>
  <body>
    <textarea id="source">
class: center, middle, inverse, title-slide

# OBRADA PODATAKA
## Predavanje 5: Manipulacija i prilagodba podataka (data.table)
### Luka Sikic, PhD
### Fakultet hrvatskih studija | <a href="https://github.com/BrbanMiro/Obrada-podataka">OP</a>

---

name: toc

&lt;style type="text/css"&gt;
.large4 { font-size: 400% }
.large2 { font-size: 200% }
.small90 { font-size: 90% }
.small75 { font-size: 75% }
&lt;/style&gt;



# Pregled predavanja


1. [Set-up](#prologue)

2. [Uvod](#intro)

3. [data.table osnove](#basics)

4. [Manipulacija redovima: DT[i, ]](#i)

5. [Manipulacija kolonama: DT[, j]](#j)

6. [Grupiranje: DT[, , by]](#by)

7. [Ključevi](#keys)

8. [Spajanje podataka](#merge)

9. [Preoblikovanje](#reshape)

10. [data.table + tidyverse](#tidyverse)

10. [Sažetak](#summary)


---
class: inverse, center, middle
name: prologue

# Set-up

&lt;html&gt;&lt;div style='float:left'&gt;&lt;/div&gt;&lt;hr color='#EB811B' size=1px width=796px&gt;&lt;/html&gt;
(Postavke za rad sa data.table paketom!)
---

# Checklist

We'll be using the following packages in today's lecture:
- Already installed: **dplyr**, **ggplot2**, **nycflights13**
- New: **data.table**, **tidyfast**, **dtplyr**, **microbenchmark**

--

Ovaj kod će instalirati (ako je potrebno) i učitati sve potrebne pakete za predavanje.


```r
if (!require(pacman)) install.packages('pacman', repos = 'https://cran.rstudio.com')
```

```
## Warning: package 'pacman' was built under R version 4.0.3
```

```r
pacman::p_load(dplyr, data.table, dtplyr, tidyfast, microbenchmark, ggplot2, nycflights13)
options(dplyr.summarise.inform = FALSE) ## Isključi dplyr group_by poruke 
```

---
class: inverse, center, middle
name: intro

# Uvod

&lt;html&gt;&lt;div style='float:left'&gt;&lt;/div&gt;&lt;hr color='#EB811B' size=1px width=796px&gt;&lt;/html&gt;
(Osnova za korištenje data.table paketa!)



---

# Zašto uopće data.table?

**tidyverse** je sjajan način za manipulaciju podatcima. Također, može se koristiti za rad sa Big Data podatcima  (SQL databases, Spark, etc.)

--

Zašto je potrebna druga sintaksa za manipulaciju podatcima?

--

Nekoliko je razloga za  **data.table**:

1. Koncizna sintaksa
2. Nevjerojatna brznia
3. Memorijska efikasnost
4. Mnoštvo mogućnosti (+ stabilnost)
5. Nema zavisnosti (o drugim paketima, instalacijama, etc.)

--

Prije detalja, pogledajte nekoliko primjera...

---

# Zašto uopće data.table? (dalje)

### 1) Konciznost

Ova dva koda postižu istu stvar:

```r
# library(dplyr) ## Učitano
# data(starwars, package = "dplyr") ## Uvezi podatke u GEnvir
starwars %&gt;% 
  filter(species=="Human") %&gt;% 
  group_by(homeworld) %&gt;% 
  summarise(mean_height=mean(height)) 
```
vs
```r
# library(data.table) ## Učitano
starwars_dt = as.data.table(starwars)
starwars_dt[species=="Human", mean(height), by=homeworld]
```

---
name:fast

# Zašto uopće data.table? (dalje)

### 2) Brzina

.small90[


```r
collapse_dplyr = function() {
  storms %&gt;%
    group_by(name, year, month, day) %&gt;% 
    summarize(wind = mean(wind), pressure = mean(pressure), category = dplyr::first(category))
  }
storms_dt = as.data.table(storms)
collapse_dt = function() {
  storms_dt[, .(wind = mean(wind), pressure = mean(pressure), category = first(category)),
            by = .(name, year, month, day)]
  }
microbenchmark(collapse_dplyr(), collapse_dt(), times = 10)
```

```
## Unit: milliseconds
##              expr      min       lq      mean    median       uq      max neval
##  collapse_dplyr() 121.4271 136.5441 147.48845 143.75100 153.2597 190.6388    10
##     collapse_dt()   2.3583   2.6939   3.82609   2.83105   3.3484   8.7030    10
```
]

--

.small90[
**Rezultat:** data.table je 75x brža! 
]

---

# Zašto uopće data.table? (dalje)

### 3) Efikasnost

Mjerenje i usporedba memorijske efikasnosti [je relativno komplicirano](https://stackoverflow.com/a/61376971). Za detalje [pogledajte](https://jangorecki.gitlab.io/r-talks/2019-06-18_Poznan_why-data.table/why-data.table.pdf) (nakon 12-og slide) za detaljnjiji pregled data.table efikasnosti.

### 4) Mogućnosti i 5) Nezavisnost

Ova dva čimbenika idu zajedno jer su povezani sa stabilnošću koda. Nezavisnost se ondosi na  [na](http://www.tinyverse.org/):


```r
tools::package_dependencies("data.table", recursive = TRUE)[[1]]
```
```
## [1] "methods"
```


```r
tools::package_dependencies("dplyr", recursive = TRUE)[[1]]
```
```
##  [1] "ellipsis"   "assertthat" "glue"       "magrittr"   "methods"    "pkgconfig" 
##  [7] "R6"         "Rcpp"       "rlang"      "tibble"     "tidyselect" "utils"     
## [13] "BH"         "plogr"      "tools"      "cli"        "crayon"     "fansi"     
## [19] "lifecycle"  "pillar"     "vctrs"      "purrr"      "grDevices"  "utf8"      
## [25] "digest"  
```

---

# Prije nastavka...

Cilj ovog predavanja *nije* pokazati da je data.table superiorniji pristup od tidyverse. (Niti  vice versa.)

Ljudi imaju različite stavove i to je u redu...

Cilje je prikazati još jedan alat kojim se može manipulirati velikim (i malim) skupovima podataka na efikasan način u programosm jeziku R..

--


- Poznavanje oba pristupa će vam povećati efikasnost i napraviti od vas boljeg R korisnika/istraživača/podatkovnog znanstvenika/etc.

--

Aspekt komplementarnosti ćemo obraditi na kraju predavanja. 

---

class: inverse, center, middle
name: basics

# data.table osnove
&lt;html&gt;&lt;div style='float:left'&gt;&lt;/div&gt;&lt;hr color='#EB811B' size=1px width=796px&gt;&lt;/html&gt;
(Snalaženje u sintaksi paketa!)
---

# data.table objekt

Već smo vidjeli da `tidyerse` omogućava specifičnu i unaprijeđenu varijantu `data.frame`-a u formi `tibble` .

--

Jednako vrijedi i za `data.table` . `data.table` zapravo rade samo na objektima koji su prvo pretvoreni u `data.table`.slično kao `tibble`), specijalna interna struktura `data.table` objekta je glavni razlog zašto je paket tako brz. (Više pogledajte [ovdje](https://rdatatable.gitlab.io/data.table/articles/datatable-intro.html#what-is-datatable-1a) i [ovdje](https://twitter.com/matloff/status/1131372631372918784).)

--

Nekoliko je opcija za napravit `data.table`:
- `fread('mydata.csv')` učitava `CSV` u `R` kao `data.table` (i extremno brzo).&lt;sup&gt;1&lt;/sup&gt;
- `data.table(x = 1:10)` stvara novi `data.table` ni iz čega
- `as.data.table(df)` pretvara postojeći `data.frame` (dalje: `df`) u `data.table`.
- `setDT(df)` pretvara postojeći `df` u `data.table` *prema referenci*; i.e. nije potreban (re)assign


.footnote[&lt;sup&gt;1&lt;/sup&gt; Funkciju `fread()` ćemo detaljnije spominjati u nadolazećim predavanjima.]

---

# Što znači "pretvaranje prema referenci"?

Upravo je to ono što čini data.table tako izvrsnim: modifikacije se, u slučaju gdje je to moguće, izvode *prema referenci*.

--

Što to znači? 

--

Bez da ulazimo u detalje, kratko objašnjenje se odnosi na to da R ima dva načina za izmjenu i pripisivanje objekata.
1. **Copy-on-modify:** Stvara kopiju podataka. Implicira dodate računalne resurse.&lt;sup&gt;*&lt;/sup&gt;
2. **Modify-in-place:** Ne stvara kopiju nego direktno utječe na memoriju. 

.footnote[&lt;sup&gt;*&lt;/sup&gt; Valja spomenuti da je važno  napraviti distinkciju između &lt;i&gt;shallow&lt;/i&gt; i &lt;i&gt;deep copies&lt;/i&gt;.]

--

data.table "modificira prema referenci" jer modificira objekte na **modify-in-place:** način. Upravo to povećava efikasnost i smanjuje memorisjku zahtjevnost!

--

P.S.Dodatno pogledajte ako vas ovo zanima: (a) [Reference semantics](https://rdatatable.gitlab.io/data.table/articles/datatable-reference-semantics.html) data.table vignette, (b) [Names and Values](https://adv-r.hadley.nz/names-values.html) poglavlja *Advanced R* (Hadley Wickham), (c) Izvrstan i protočan [blog post](https://tysonbarrett.com//jekyll/update/2019/07/12/datatable/).

---

# data.table sintaksa

Sve data.table objekti prihvaćaju jednaku osnovnu sintaksu:

.center[
.large2[DT[&lt;span style='color: #66C2A5;'&gt;i&lt;/span&gt;, &lt;span style='color: #FC8D62;'&gt;j&lt;/span&gt;, &lt;span style='color: #8DA0CB;'&gt;by&lt;/span&gt;]]
]

![:col_row &lt;span style='color: #66C2A5;'&gt;Po kojim redovima?&lt;/span&gt;, &lt;span style='color: #FC8D62;'&gt;Što učiniti?&lt;/span&gt;, &lt;span style='color: #8DA0CB;'&gt;Grupiranje prema...&lt;/span&gt;]

--

.center[dplyr "equivalents":]
![:col_list &lt;span style='color: #66C2A5;'&gt;filter(); slice(); arrange()&lt;/span&gt;, &lt;span style='color: #FC8D62;'&gt;select(); mutate()&lt;/span&gt;, &lt;span style='color: #8DA0CB;'&gt;group_by()&lt;/span&gt;]

--

tidyverse izvršava operacije korok po korak, a data.table izvršava sve u jednom koraku.
- Na taj je način moguće izvršiti kompleksnu naredbu kao jednu fluidnu misao.
- Ulančavanje pitem pipe operatora je također moguće.

---

# Brzi primjer

Detalji sljede nakon kratkog data.table primjera. 

Brza paralelna usporedba sa dplyr jer će to motivirati predavanje. Na stawars podatcima postavimo pitanje:
&gt; Koja je prosječna visina ljudi po spolu?

--

.pull-left[
### dplyr

```r
data(starwars, package = "dplyr")
starwars %&gt;%
  filter(species=="Human") %&gt;%
  group_by(gender) %&gt;%
  summarise(mean(height, na.rm=T))
```

]

.pull-right[
### data.table

```r
starwars_dt = as.data.table(starwars)
starwars_dt[
  species=="Human", 
  mean(height, na.rm=T), 
  by = gender]
```
]

---

# Brzi primjer

Detalji sljede nakon kratkog data.table primjera. 

Brza paralelna usporedba sa dplyr jer će to motivirati predavanje. Na stawars podatcima postavimo pitanje:
&gt; Koja je prosječna visina ljudi po spolu?
.pull-left[
### dplyr

```r
data(starwars, package = "dplyr")
starwars %&gt;%
* filter(species=="Human") %&gt;%
  group_by(gender) %&gt;%
  summarise(mean(height, na.rm=T))
```

]

.pull-right[
### data.table

```r
starwars_dt = as.data.table(starwars)
starwars_dt[
* species=="Human", ## i
  mean(height, na.rm=T), 
  by = gender]
```
]

---

# Brzi primjer

Detalji sljede nakon kratkog data.table primjera. 

Brza paralelna usporedba sa dplyr jer će to motivirati predavanje. Na stawars podatcima postavimo pitanje:
&gt; Koja je prosječna visina ljudi po spolu?
.pull-left[
### dplyr

```r
data(starwars, package = "dplyr")
starwars %&gt;%
  filter(species=="Human") %&gt;% 
  group_by(gender) %&gt;%
* summarise(mean(height, na.rm=T))
```

]

.pull-right[
### data.table

```r
starwars_dt = as.data.table(starwars)
starwars_dt[
  species=="Human",
* mean(height, na.rm=T),  ## j
  by = gender]
```
]

---


# Brzi primjer

Detalji sljede nakon kratkog data.table primjera. 

Brza paralelna usporedba sa dplyr jer će to motivirati predavanje. Na stawars podatcima postavimo pitanje:
&gt; Koja je prosječna visina ljudi po spolu?
.pull-left[
### dplyr

```r
data(starwars, package = "dplyr")
starwars %&gt;%
  filter(species=="Human") %&gt;% 
* group_by(gender) %&gt;%
  summarise(mean(height, na.rm=T)) 
```

]

.pull-right[
### data.table

```r
starwars_dt = as.data.table(starwars)
starwars_dt[
  species=="Human",
  mean(height, na.rm=T),  
* by = gender] ## by
```
]

---


# Brzi primjer

Detalji sljede nakon kratkog data.table primjera. 

Brza paralelna usporedba sa dplyr jer će to motivirati predavanje. Na stawars podatcima postavimo pitanje:
&gt; Koja je prosječna visina ljudi po spolu?
.pull-left[
### dplyr

```r
data(starwars, package = "dplyr")
starwars %&gt;%
  filter(species=="Human") %&gt;%
  group_by(gender) %&gt;%
  summarise(mean(height, na.rm=T))
```

```
## # A tibble: 2 x 2
##   gender    `mean(height, na.rm = T)`
##   &lt;chr&gt;                         &lt;dbl&gt;
## 1 feminine                       160.
## 2 masculine                      182.
```

]

.pull-right[
### data.table

```r
starwars_dt = as.data.table(starwars)
starwars_dt[
  species=="Human", 
  mean(height, na.rm=T), 
  by = gender]
```

```
##       gender       V1
## 1: masculine 182.3478
## 2:  feminine 160.2500
```
]

---
class: inverse, center, middle
name: i

# Manipulacija redovima: DT[i, ]
&lt;html&gt;&lt;div style='float:left'&gt;&lt;/div&gt;&lt;hr color='#EB811B' size=1px width=796px&gt;&lt;/html&gt;
(Smjer prema dolje!)
---

# Indeksiranje po redovima (filter)

Indeksiranje po redovima je jednostavnu u data.table. ESve radi kao očekivano ako imate iskustvo sa dplyr. 

- `DT[x == "string", ]`: Izdvoji redove x koji su jednaki "string"

- `DT[y &gt; 5, ]`: Izdvoji redove u kojima je varijabla y veća od 5

- `DT[1:10, ]`: Izdvoji prvih 10 redova

--

Mnogostruki uvjeti su također dozvoljeni:

- `DT[x=="string" &amp; y&gt;5, ]`: Izdvoji redove gdje je x  "string" **I** y je veći od 5

--

Primijetite da ne trebamo zareze kada indeksiramo po `i` (i.e. niti `j` niti `by` funkcijske argumente).
- `DT[x=="string"]` je isto kao `DT[x=="string", ]`
- `DT[1:10]` je isto kao `DT[1:10, ]`
- etc.

---

# Indeksiranje po redovima (filter) (*dalje*)

Ovdje je prethodni primjer indeksiranja na starwars data.table podatcima (objektu).


```r
starwars_dt[height&gt;190 &amp; species=='Human']
```

```
##                   name height mass hair_color skin_color eye_color birth_year
## 1:         Darth Vader    202  136       none      white    yellow       41.9
## 2:        Qui-Gon Jinn    193   89      brown       fair      blue       92.0
## 3:               Dooku    193   80      white       fair     brown      102.0
## 4: Bail Prestor Organa    191   NA      black        tan     brown       67.0
##     sex    gender homeworld species
## 1: male masculine  Tatooine   Human
## 2: male masculine      &lt;NA&gt;   Human
## 3: male masculine   Serenno   Human
## 4: male masculine  Alderaan   Human
##                                                                        films
## 1: The Empire Strikes Back,Revenge of the Sith,Return of the Jedi,A New Hope
## 2:                                                        The Phantom Menace
## 3:                                  Attack of the Clones,Revenge of the Sith
## 4:                                  Attack of the Clones,Revenge of the Sith
##            vehicles       starships
## 1:                  TIE Advanced x1
## 2:  Tribubble bongo                
## 3: Flitknot speeder                
## 4:
```

---

# Posloži po redovima (arrange)

```r
starwars_dt[order(birth_year)]  ## (privremeno) sortiraj od najmlađeg prema najstarijem
starwars_dt[order(-birth_year)] ## (privremeno) sortiraj od najstarijeg prema najmlađem
```

--

data.table također omogućava optimiziranu `setorder()` funkciju uz slaganje *prema referenci* (*by reference*).

--


```r
setorder(starwars_dt, birth_year, na.last = TRUE)
starwars_dt[1:5, name:birth_year] ## Prikaži samo dio podataka
```

```
##                     name height mass hair_color skin_color eye_color birth_year
## 1: Wicket Systri Warrick     88   20      brown      brown     brown          8
## 2:                 IG-88    200  140       none      metal       red         15
## 3:        Luke Skywalker    172   77      blond       fair      blue         19
## 4:           Leia Organa    150   49      brown      light     brown         19
## 5:        Wedge Antilles    170   77      brown       fair     hazel         21
```




---
class: inverse, center, middle
name: j

# Manipulacija kolonama: DT[, j]
&lt;html&gt;&lt;div style='float:left'&gt;&lt;/div&gt;&lt;hr color='#EB811B' size=1px width=796px&gt;&lt;/html&gt;
(Smjer desno!)
---

# j: jedno pravilo za sve

Prisjetimo se nekih dplyr funkcija:

- `select()`
- `mutate()`
- `summarise()`
- `count()`

--

data.table prepoznaje sve pobrojane funkcije... 
&gt;"*Učini nešto sa ovom varijablom u mojem podatkovnom skupu!*"
... i omogućava da se sve napravi na jednom mjestu: u `j` slot-u.

--
Ipak, potrebno je par sintaktičkih hack-ova vezanih uz način kako pripisujemo varijable u podatkovnom skupu.
- Neki će smatrati ovo odbojnim (ili barem, čudnim) kada se prvi put susretnu sa data.table.
- Zapravo se ne radi ni o čemu posebno kompleksnom, a za uzvrat daje *puno* moći.

---

# Modifikacija kolona sa :=

Za dodavanje, brisanje, mijenjanje u data.table se koristi **`:=`** operator.
- Drugi naziv je *walrus* operator.

--

Na primjer,

- `DT[, xsq := x^2]`: Napravi novu kolonu (`xsq`) od postojeće (`x`)
- `DT[, x := as.character(x)]`: Promijeni postojeću kolonu

--

**Važno:** `:=` je *modifikacija prema referenci*, i.e. "na mjestu". Zbog toga nije potrebno pripisivati promjene novom objektu.

--

Zbog toga promjene na objektu nisu vidljive ukoliko to eksplicitno ne tražimo od R.


```r
DT = data.table(x = 1:2)
# DT[, xsq := x^2] ## Promjena na mjestu bez prikaza
DT[, x_sq := x^2][] ## Dodaj [] za prikaz razultata
```

```
##    x x_sq
## 1: 1    1
## 2: 2    4
```

---

# Modifikacija kolona sa := (dalje)


*Modifikacija prema referenci* ima važne implikacije za manipulaciju podatcima. Razmislite što se događa ako kopiramo data.table i nakon toga meknemo kolonu.


```r
DT_copy = DT
DT_copy[, x_sq := NULL]
```

--

Očito, "x_sq" je izbrisan iz `DT_copy` objekta. ...ali što se dogodilo sa originalnim `DT` objektom?

--


```r
DT
```

```
##    x
## 1: 1
## 2: 2
```

--
Također izbrisano...baš kao što modifikacij prema referenci traži. Kako bismo izbjegli ovakvo "ponašanje", moguće je koristit [`data.table::copy()`](https://rdatatable.gitlab.io/data.table/reference/copy.html) funkciju. Probajte izvšiti sljedeću naredbu:


```r
DT[, x_sq := x^2]     
DT_copy = copy(DT)  
DT_copy[, x_sq := NULL]
DT ## x_sq je još uvijek tu!
```


---

# Modifikacija kolona sa := (dalje)

### Pod-pripisivanje prema referenci

Jedna fantastična funkcionalnost `:=` je data.table [sub-assign by reference](https://rdatatable.gitlab.io/data.table/articles/datatable-reference-semantics.html#ref-i-j) functionality. ZA primjer razmotrimo jedan (lažni) skup podataka.


```r
DT2 = data.table(a = -2:2, b = LETTERS[1:5])
```

--

Zamislite da želimo locirati redove gdje je "a" negativan i zamijeniti pripadajuću "b" ćeliju sa NA. 

--

- U dplyr je potrebno napraviti `...mutate(b = ifelse(a &lt; 0, NA, b))`.
--

- U data.table, jednstavno specificirajte redove (`i`) i onda pod-pripišite (`j`) direktno.


```r
DT2[a &lt; 0, b := NA][] ## Dodajte [] za prikaz na eranu
```

```
##     a    b
## 1: -2 &lt;NA&gt;
## 2: -1 &lt;NA&gt;
## 3:  0    C
## 4:  1    D
## 5:  2    E
```


---

# Modifikacija kolona sa := (dalje)

Dvije su mogućnosti za manipulaciju više kolna odjednom.

1. LHS `:=` RHS forma: `DT[, c("var1", "var2") := .(val1, val2)]`

2. Funkcionalna forma: `DT[, ':=' (var1=val1, var2=val2)]`

--

Osobno preporučam funkcionalnu formu pa ćemo to koristiti dalje. E.g.


```r
DT[, ':=' (y = 3:4, y_name = c("three", "four"))]
DT ## Drugi način za print pored []
```

```
##    x x_sq y y_name
## 1: 1    1 3  three
## 2: 2    4 4   four
```

--

Dinamičko pripisivanje zavisnih kolona u jednom koraku (kao kod dplyr::mutate) ne funkcionira.


```r
DT[, ':=' (z = 5:6, z_sq = z^2)][]
```

```
## Error in eval(jsub, SDenv, parent.frame()): object 'z' not found
```

---

# Dodatak: Ulančavanje data.table operacija

Zadnji primjer je ne poakzuje da nije moguće raditi ulančane operacije sa data.table.

--

Prirodni data.table način je dodavanje sukcesivnih `[]` operatora.


```r
DT[, z := 5:6][, z_sq := z^2][] 
```

```
##    x x_sq y y_name z z_sq
## 1: 1    1 3  three 5   25
## 2: 2    4 4   four 6   36
```

--

Ako preferirate **magrittr** pipe operator...dodajte prefiks na `.` na svakom koraku:


```r
# library(magrittr) ## Nije potrebno jer je %&gt;% već učitan via dplyr
DT %&gt;%
  .[, xyz := x+y+z] %&gt;%
  .[, xyz_sq := xyz^2] %&gt;%
  .[] 
```

```
##    x x_sq y y_name z z_sq xyz xyz_sq
## 1: 1    1 3  three 5   25   9     81
## 2: 2    4 4   four 6   36  12    144
```

---

# Modifikacija kolona sa := (dalje)

Za brisanje kolone u podatkovnom skupu možete koristiti NULL.


```r
DT[, y_name := NULL]
DT
```

```
##    x x_sq y z z_sq xyz xyz_sq
## 1: 1    1 3 5   25   9     81
## 2: 2    4 4 6   36  12    144
```


---

# Indeksiranje po kolonama (select)

Moguće je koristiti `j` slot za indeksiranje podataka po kolonama. Pogledajmo starwars podatke za ove primjere...

--

Indeksiraj prema poziciji kolone:

```r
starwars_dt[1:2, c(1:3, 10)]
```

```
##                     name height mass homeworld
## 1: Wicket Systri Warrick     88   20     Endor
## 2:                 IG-88    200  140      &lt;NA&gt;
```

--
...ili po nazivu:


```r
# starwars_dt[, c("name", "height", "mass", "homeworld")] ## također radi
# starwars_dt[, list(name, height, mass, homeworld)] ## i ovo isto
starwars_dt[1:2, .(name, height, mass, homeworld)]
```

```
##                     name height mass homeworld
## 1: Wicket Systri Warrick     88   20     Endor
## 2:                 IG-88    200  140      &lt;NA&gt;
```

---

# Dodatak: Zašto pak .()?

Već smo vidjeli `.()`na par mjestas, e.g trethodni i [ovaj](#fast) slide ako se sijećate.
- `.()` je samo data.table kratica za `list()`. 

Obilato ćemo koristiti `.()` kada krenemo sa indeksiranjem i/ili grupiranjem više varijabli od jednom.

Možete si objasniti da su to sintaktičke osobine data.table ali zapravo je riječ o pristupu koristiti ovo izmjenično u data.table:
- `.(var1, var2, ...)`
- `list(var1, var2, ...)`
- `c("var1", "var2", ...)`

--

Meni je `.()` sintaksa izvrsna &amp;mdash; manje tipkanja! &amp;mdash; ali svatko kako voli!

--

Vratimo se indeksiranju kolona...

---

# Indeksiranje po kolonama (select)

Kolone također možete obrisati negacijom. Isprobajte sljedeći kod:


```r
starwars_dt[, !c("name", "height")]
```

--

### Preimenovanje kolona

Preimenovanje kolona/e prema referenci. Isprobajte sljedeći kod sami:


```r
setnames(starwars_dt, old = c("name", "homeworld"), new = c"(alias", "crib"))[]
## Promijeni nazad, možda će varijable "name" ili "homeworld" trebati za poslje
setnames(starwars_dt, old = c("alias", "crib"), new = c("name", "homeworld"))
```

--

`setnames()` pruža neke prednosti  u performansama, nekada želite dinamički preimenovati kolone pri indeksiranju. Primjerice:


```r
starwars_dt[1:2, .(alias = name, crib = homeworld)]
```

```
##                    alias  crib
## 1: Wicket Systri Warrick Endor
## 2:                 IG-88  &lt;NA&gt;
```

---

# Indeksiranje po kolonama (select)

Također valja napomenuti da dplyr gramatika radi i na data.table objektima. 

Probajte izvšiti sljedeći kod. (Dobiti ćete upozorenje o gubitku efikasnosti.)


```r
starwars_dt[1:5, ] %&gt;% 
  select(crib = homeworld, everything())
```

--

Vratiti ćemo se još jednom na dplyr+data.table funkcionalnost na kraju predavanja....

---

# Agregacija

Moguće su i operacije agregiranja na `j`.


```r
starwars_dt[, mean(height, na.rm=T)]
```

```
## [1] 174.358
```

--

Sjetite se da ne zadržavamo ništa ako ne pripišemo rezultat novom objektu. Za dodavanje nove kolone sa rezultatima originalnom podatkovnom skupu koristite `:=`.


```r
starwars_dt[, mean_height := mean(height, na.rm=T)] %&gt;% ## Dodaj prosječnu visinu kao kolonu
  .[1:5, .(name, height, mean_height)] ## Zadrži sve
```

```
##              name height mean_height
## 1: Luke Skywalker    172     174.358
## 2:          C-3PO    167     174.358
## 3:          R2-D2     96     174.358
## 4:    Darth Vader    202     174.358
## 5:    Leia Organa    150     174.358
```

---
# Agregacija (dalje)


data.table također omogućava [special convenience symbols](https://rdatatable.gitlab.io/data.table/reference/special-symbols.html) za uobičajne agregacijske operacije na `j`.

Na primjer, moguće je izbrojati opervacije sa `.N`.


```r
starwars_dt[, .N]
```

```
## [1] 87
```

--

Naravno,to je poprilično stiliziran primjer jer ćemo dobiti samo ukupni broj redova u podatcima. Kao i druge agregacijske funkcije `.N` je puno interesantniji kada je primjenjen na grupirane podatke.
- Ovo je uvod u narednu temu...




---
name: by
class: inverse, center, middle

# Grupiranje: DT[, , by]
&lt;html&gt;&lt;div style='float:left'&gt;&lt;/div&gt;&lt;hr color='#EB811B' size=1px width=796px&gt;&lt;/html&gt;
(Jako korisno!)
---

# by

data.table `by` argument funkcinira slično `dplyr::group_by` ekvivalentu. Isprobajte sljedeće naredbe u vlastitoj R konzoli:

- `starwars_dt[, mean(height, na.rm=T), by = species]`: Kolapsiraj po varijabli
- `starwars_dt[, .(species_height = mean(height, na.rm=T)), by = species]`: Kao gore ali po nazivu summary varijable
- `starwars_dt[, mean(mass, na.rm=T), by = height&gt;190]`: Uvjeti također rade.
- `starwars_dt[, species_n := .N, by = species][]`: Dodaj agregiranu kolonu podatcima (ovdje: broj opservacija po grupama)

--

Za agregaciju po više varijabli možete koristit `.()` sintaksu.


```r
starwars_dt[, .(mean_height = mean(height, na.rm=T)), by = .(species, homeworld)] %&gt;%
  head(4) ## stane na slide
```

```
##    species homeworld mean_height
## 1:   Human  Tatooine    179.2500
## 2:   Droid  Tatooine    132.0000
## 3:   Droid     Naboo     96.0000
## 4:   Human  Alderaan    176.3333
```

---

# Efikasno indeksiranje sa .SD

Vidjeli smo kao grupirati više varijabli. Što ako želimo *summarise* više varijabli, nevezano uz to kako grupiramo?

Jedno rješenje je ponovno`.()` Raspišite sve, e.g.


```r
## isprobajte sami
starwars_dt[, 
            .(mean(height, na.rm=T), mean(mass, na.rm=T), mean(birth_year, na.rm=T)), 
            by = species]
```
--

Ovo može postati zamorno. zamislite još varijabli... DDa li stvarno moramo pisati `mean(..., na.rm=T)` za svaku varijablu?

--

Odgovor je naravno, "ne". data.table ima `.SD` simbol za **s**ubsetting **d**ata. .SD može [i mnogo više](https://rdatatable.gitlab.io/data.table/articles/datatable-sd-usage.html) nego što ćemo prikazati, ali ovako bismo to primijenili u trenutnom slučaju...

.right[**See next slide*Vidi sljedeći slide.*]

---

# Efikasno indeksiranje sa .SD (nastavak)


```r
starwars_dt[, 
            lapply(.SD, mean, na.rm=T),
            .SDcols = c("height", "mass", "birth_year"),
            by = species] %&gt;% 
  head(2) ## Zadrži sve na jednom slide
```

```
##    species height  mass birth_year
## 1:    Ewok   88.0 20.00    8.00000
## 2:   Droid  131.2 69.75   53.33333
```

---
count: false

# Efikasno indeksiranje sa .SD (nastavak)


```r
starwars_dt[, 
*           lapply(.SD, mean, na.rm=T),
            .SDcols = c("height", "mass", "birth_year"),
            by = species] %&gt;%
  head(2) ## adrži sve na jednom slide
```

```
##    species height  mass birth_year
## 1:    Ewok   88.0 20.00    8.00000
## 2:   Droid  131.2 69.75   53.33333
```

Prvo, specificirajmo što želimo *učiniti* na dijelu podataka (i.e. `.SD`). U ovom slučaju želimo prosjek za svaku varijablu, što postižemo sa base R funkcijom `lapply()`.&lt;sup&gt;1&lt;/sup&gt;

.footnote[
&lt;sup&gt;1&lt;/sup&gt; Riječ je o iteracijskoj funkciji. Dio R koji se bavi radom sa funkcijama.
]

---
count: false

# Efikasno indeksiranje sa .SD (nastavak)


```r
starwars_dt[, 
            lapply(.SD, mean, na.rm=T), 
*           .SDcols = c("height", "mass", "birth_year"),
            by = species] %&gt;%
  head(2) ## Zadrži sve na slide
```

```
##    species height  mass birth_year
## 1:    Ewok   88.0 20.00    8.00000
## 2:   Droid  131.2 69.75   53.33333
```

Prvo, specificirajmo što želimo *učiniti* na dijelu podataka (i.e. `.SD`). U ovom slučaju želimo prosjek za svaku varijablu, što postižemo sa base R funkcijom `lapply()`.&lt;sup&gt;1&lt;/sup&gt;

Potom specificiramo *koje kolone* želimo indeksirati sa `.SDcols` argumentom.

.footnote[
&lt;sup&gt;1&lt;/sup&gt; Riječ je o iteracijskoj funkciji. Dio R koji se bavi radom sa funkcijama.
]

---
count: false

# Efficient subsetting with .SD (cont.)


```r
starwars_dt[, 
            lapply(.SD, mean, na.rm=T), 
            .SDcols = c("height", "mass", "birth_year"), 
            by = species] %&gt;%
  head(2) ## Just keep everything on the slide
```

```
##    species height  mass birth_year
## 1:    Ewok   88.0 20.00    8.00000
## 2:   Droid  131.2 69.75   53.33333
```

Prvo, specificirajmo što želimo *učiniti* na dijelu podataka (i.e. `.SD`). U ovom slučaju želimo prosjek za svaku varijablu, što postižemo sa base R funkcijom `lapply()`.&lt;sup&gt;1&lt;/sup&gt;

Potom specificiramo *koje kolone* želimo indeksirati sa `.SDcols` argumentom.

P.S. `.()` ne funkcionira sa `.SDcols`. Ipak,moguće je korisiti navodnike, e.g. `.SDcols = height:mass`. [Vidi za detalje](https://rdatatable.gitlab.io/data.table/articles/datatable-intro.html#how-can-we-specify-just-the-columns-we-would-like-to-compute-the-mean-on).
.footnote[
&lt;sup&gt;1&lt;/sup&gt; Riječ je o iteracijskoj funkciji. Dio R koji se bavi radom sa funkcijama.
]
---

# Efficient subsetting with .SD (cont.)

Dodatak: `.SDcols` je potrebno specificirati samo ako želimo indeksirati dio podataka. (Ovakve naredbe su također dozvoljene `.SDcols = is.numeric` ili `.SDcols = patterns('abc')`.)

Ako želimo istu funkciju primijeniti na *sve* varijable u podatkovnom skupu, tada će `.SD` biti dovoljno. 

--

Za brzi primjer se prisjetite DT objekta koji ima samo numeričke varijable.


```r
DT
```

```
##    x x_sq y z z_sq xyz xyz_sq
## 1: 1    1 3 5   25   9     81
## 2: 2    4 4 6   36  12    144
```

--

Projske za svaku varijablu možemo dobiti na sljedeći način.


```r
DT[, lapply(.SD, mean)]
```

```
##      x x_sq   y   z z_sq  xyz xyz_sq
## 1: 1.5  2.5 3.5 5.5 30.5 10.5  112.5
```

---

# keyby

Zadnja stvar koju treba spomenuti vezano uz `by` je srodna funkcija: `keyby`.

`keyby` argument funkcionira isto kao `by` &amp;mdash; također se može koristit i drop-in zamjena &amp;mdash; osim što poreda opservacije i stvara **key**.
- Postavljanje ključa za data.table će omogućiti razne (i često zapanjujuće) funkcionalnosti i poboljšanje performansi.&lt;sup&gt;1&lt;/sup&gt;
- Ključevi su toliko važni (i korisni) da će ćemo ih obraditi detaljnije u sljedećem dijelu...

.footnote[&lt;sup&gt;1&lt;/sup&gt; Nećete vidjeti trenutno poboljšanje performansi sa `keyby`, ali naknadne operacije će "profitirati". (Trenutno poboljšanje je ipak mogue ako unaprijed postavite ključ, ali to ćemo objasniti na sljedećem slide-u...)]



---
name: keys
class: inverse, center, middle

# Keys
&lt;html&gt;&lt;div style='float:left'&gt;&lt;/div&gt;&lt;hr color='#EB811B' size=1px width=796px&gt;&lt;/html&gt;

---

# What are keys?

Keys are a way of ordering the data that allows for *extremely* fast subsetting.

The data.table [vignette](https://rdatatable.gitlab.io/data.table/articles/datatable-keys-fast-subset.html) describes them as "supercharged rownames". I know that might sound a bit abstract, but here's the idea in a nutshell...

--

Imagine that we want to filter a dataset based on a particular value (e.g. find all the human characters in our starwars dataset).
- Normally, we'd have to search through the whole dataset to identify matching cases.
- But, if we've set an appropriate key, then the data are already ordered in such a way that we (i.e. our computer) only has to search through a much smaller subset.

--

**Analogy:** Think of the way a filing cabinet might divide items by alphabetical order: Files starting "ABC" in the top drawer, "DEF" in the second drawer, etc. To find *Alice's* file, you'd only have to search the top draw. For *Fred*, the second draw, and so on.

--

Not only is this much quicker, but the same idea also carries over to *all other* forms of data manipulation that rely on subsetting (aggregation by group, joins, etc.)

--

P.S. We'll get there later in the course, but keys are also the secret sauce in databases.

---

# How do I set a key?

You can set a key when you first create a data.table. E.g.
- `DT = data.table(x = 1:10, y = LETTERS[1:10], key = "x")`
- `DT = as.data.table(DF, key = "x")`
- `setDT(DF, key = "x")`

--

Or, you can set keys on an existing data.table with the `setkey()` function.
- `setkey(DT, x)`: Note that the key doesn't have to be quoted this time

--

**Important:** Since keys just describe a particular ordering of the data, you can set a key on *multiple* columns. (More [here](https://rdatatable.gitlab.io/data.table/articles/datatable-keys-fast-subset.html#key-properties).) E.g.
- `DT = as.data.table(DF, key = c("x", "y"))`
- `setkey(DT, x, y)`: Again, no quotes needed

--

&lt;/br&gt;
P.S. Use the `key()` function to see what keys are currently set for your data.table. You can only ever have one key per table at a time, but it's very easy to change them using one of the above commands.
---

# Example

Recall the [speed benchmark](#fast) that we saw at the very beginning of the lecture: data.table ended up being 75x faster than dplyr for a fairly standard summarising task.

--

Let's redo the benchmark, but this time include a version where we pre-assign a key. For optimal performance, the key should match the same variables that we're grouping/subsetting on. 
- Again, a key can be set on multiple variables, although the lead grouping variable (in the below case: "name") is the most important.

--

.small90[

```r
## First create a keyed version of the storms data.table.
## Note that key variables match the 'by' grouping variables below.
storms_dt_key = as.data.table(storms, key = c("name", "year", "month", "day"))
## Collapse function for this keyed data.table. Everything else stays the same.
collapse_dt_key = function() {
  storms_dt_key[, .(wind = mean(wind), pressure = mean(pressure), category = first(category)), 
                by = .(name, year, month, day)]
}
## Run the benchmark on all three functions.
microbenchmark(collapse_dplyr(), collapse_dt(), collapse_dt_key(), times = 10)
```
]

.right[*See next slide for results*]
---

# Example (cont.)


```
## Unit: milliseconds
##               expr      min       lq      mean    median       uq      max
##   collapse_dplyr() 118.0601 118.8709 126.01164 123.63910 125.3982 154.1213
##      collapse_dt()   2.5544   2.7035   3.73972   3.18630   4.2228   7.7561
##  collapse_dt_key()   1.4000   1.5337   2.26978   1.80365   2.0338   6.6836
##  neval
##     10
##     10
##     10
```

--

The keyed data.table version is now **69** (!!!) faster than dplyr.
--

- That thing you feel... is your face melting.

--

It's not just this toy example. In working with real-life data, my experience is that setting keys almost always leads to huge speed-ups... and those gains tend to scale as the datasets increase in size.

--

**Bottom line:** data.table is already plenty fast. But use keys if you're really serious about performance.

---























---
    </textarea>
<style data-target="print-only">@media screen {.remark-slide-container{display:block;}.remark-slide-scaler{box-shadow:none;}}</style>
<script src="https://remarkjs.com/downloads/remark-latest.min.js"></script>
<script>var slideshow = remark.create({
"highlightStyle": "github",
"highlightLines": true,
"countIncrementalSlides": false
});
if (window.HTMLWidgets) slideshow.on('afterShowSlide', function (slide) {
  window.dispatchEvent(new Event('resize'));
});
(function(d) {
  var s = d.createElement("style"), r = d.querySelector(".remark-slide-scaler");
  if (!r) return;
  s.type = "text/css"; s.innerHTML = "@page {size: " + r.style.width + " " + r.style.height +"; }";
  d.head.appendChild(s);
})(document);

(function(d) {
  var el = d.getElementsByClassName("remark-slides-area");
  if (!el) return;
  var slide, slides = slideshow.getSlides(), els = el[0].children;
  for (var i = 1; i < slides.length; i++) {
    slide = slides[i];
    if (slide.properties.continued === "true" || slide.properties.count === "false") {
      els[i - 1].className += ' has-continuation';
    }
  }
  var s = d.createElement("style");
  s.type = "text/css"; s.innerHTML = "@media print { .has-continuation { display: none; } }";
  d.head.appendChild(s);
})(document);
// delete the temporary CSS (for displaying all slides initially) when the user
// starts to view slides
(function() {
  var deleted = false;
  slideshow.on('beforeShowSlide', function(slide) {
    if (deleted) return;
    var sheets = document.styleSheets, node;
    for (var i = 0; i < sheets.length; i++) {
      node = sheets[i].ownerNode;
      if (node.dataset["target"] !== "print-only") continue;
      node.parentNode.removeChild(node);
    }
    deleted = true;
  });
})();
(function() {
  "use strict"
  // Replace <script> tags in slides area to make them executable
  var scripts = document.querySelectorAll(
    '.remark-slides-area .remark-slide-container script'
  );
  if (!scripts.length) return;
  for (var i = 0; i < scripts.length; i++) {
    var s = document.createElement('script');
    var code = document.createTextNode(scripts[i].textContent);
    s.appendChild(code);
    var scriptAttrs = scripts[i].attributes;
    for (var j = 0; j < scriptAttrs.length; j++) {
      s.setAttribute(scriptAttrs[j].name, scriptAttrs[j].value);
    }
    scripts[i].parentElement.replaceChild(s, scripts[i]);
  }
})();
(function() {
  var links = document.getElementsByTagName('a');
  for (var i = 0; i < links.length; i++) {
    if (/^(https?:)?\/\//.test(links[i].getAttribute('href'))) {
      links[i].target = '_blank';
    }
  }
})();
// adds .remark-code-has-line-highlighted class to <pre> parent elements
// of code chunks containing highlighted lines with class .remark-code-line-highlighted
(function(d) {
  const hlines = d.querySelectorAll('.remark-code-line-highlighted');
  const preParents = [];
  const findPreParent = function(line, p = 0) {
    if (p > 1) return null; // traverse up no further than grandparent
    const el = line.parentElement;
    return el.tagName === "PRE" ? el : findPreParent(el, ++p);
  };

  for (let line of hlines) {
    let pre = findPreParent(line);
    if (pre && !preParents.includes(pre)) preParents.push(pre);
  }
  preParents.forEach(p => p.classList.add("remark-code-has-line-highlighted"));
})(document);</script>

<script>
slideshow._releaseMath = function(el) {
  var i, text, code, codes = el.getElementsByTagName('code');
  for (i = 0; i < codes.length;) {
    code = codes[i];
    if (code.parentNode.tagName !== 'PRE' && code.childElementCount === 0) {
      text = code.textContent;
      if (/^\\\((.|\s)+\\\)$/.test(text) || /^\\\[(.|\s)+\\\]$/.test(text) ||
          /^\$\$(.|\s)+\$\$$/.test(text) ||
          /^\\begin\{([^}]+)\}(.|\s)+\\end\{[^}]+\}$/.test(text)) {
        code.outerHTML = code.innerHTML;  // remove <code></code>
        continue;
      }
    }
    i++;
  }
};
slideshow._releaseMath(document);
</script>
<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
(function () {
  var script = document.createElement('script');
  script.type = 'text/javascript';
  script.src  = 'https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML';
  if (location.protocol !== 'file:' && /^https?:/.test(script.src))
    script.src  = script.src.replace(/^https?:/, '');
  document.getElementsByTagName('head')[0].appendChild(script);
})();
</script>
  </body>
</html>
